
## 1章

保守性が悪くなる原因

* 命名が悪い
* ネストが多い
* 重複コードが多い
* 不正値が混入しても気づかない
* 低凝集

## 2章

## 3章

* クラス単体で正常動作するよう設計する
理由
クラスが単体で正常動作するよう設計することで、使いやすい部品とするため。
まどろっこしい初期設定をせずともはじめから使える設計にします。
また、クラスが不正状態に陥りバグを生み出さないよう、
正しく操作できるメソッドのみを外部に提供します。


## 5章

データとロジックの関係性が強いクラス(凝集度が高いクラス)を作るようにする。

凝集度に影響がない場合に、staticメソッドが使える。
ログ出力用メソッドなど、凝集度に無関係なものにはstaticメソッドを使うのが良い。

初期化ロジックの分散を防ぐためには、コンストラクタをprivateにして、
代わりに目的別のおファクトリメソッドを用意するのが良い。

結果を返すために引数を用いる(出力として用いる引数である出力引数)は使わないようにする。
低凝集な構造に陥りやすいため。

引数が多いメソッドは、それだけ多くの引数に依存した処理を行っているということになるため、
凝集度が低いと言える。そのため、引数が多くならないようにする。

デメテルの法則(利用するオブジェクトの内部を知るべきではないとするもの)に沿って
考えると、階層的に属性にアクセスをするのは法則に違反している。

ソフトウェア設計には、尋ねるな、命じろという有名な格言があります。
他のオブジェクトの内部状態を尋ねたり、その状態に応じて呼び出し側が判断するのではなく、
呼び出し側はただメソッドで命ずるだけで、命令された側で適切な判断や制御を行うよう設計します。

## 6章

switch文で条件分岐をしてしまうと、様々なところで同じswitch文を書いてしまう、といったことが起こり得てしまう、、

switch文の重複コードを解消するには、単一責任原則の考え方が重要!

「ソフトウェアシステムが選択肢を提供しなければならない時、そのシステムの中の
一つのモジュールだけがその選択肢の全てを把握すべきである。」

なお、interfaceを使うと、分岐ロジックを書かずに分岐と同じことが実現可能。



## 自分のメモ
### 目的は?(Why)

### どのように?(How)

### 具体的には?(What)

